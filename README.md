# CI Demo: Dockerized Web Service

Учебный репозиторий для отработки CI: сборка Docker-образа и базовая проверка запуска сервиса.
Цель — закрепить минимальный пайплайн без деплоя на сервер.

## Что внутри
- Простое веб-приложение (Python/Flask или аналогичный сервис)
- Dockerfile для сборки образа
- GitHub Actions workflow для CI (build + smoke check)

## Требования
Локально:
- Docker
- (опционально) Python 3.x если запускаешь без Docker

## Быстрый старт (Docker)
Сборка:
```bash
docker build -t delivery-service:local .

Запуск:

docker run --rm -p 3000:5000 delivery-service:local

Проверка:

curl -i http://127.0.0.1:3000/health

Примечание по портам:

    Внутри контейнера сервис слушает порт 5000

    Снаружи пробрасываем на 3000: -p 3000:5000
    Если открыть http://127.0.0.1:3000 и ничего нет — проверь, что контейнер запущен и порт проброшен правильно.

CI (GitHub Actions)

При push в main CI выполняет:

    Checkout репозитория

    Docker build

    Smoke run контейнера (короткий запуск) / или проверка, что контейнер стартует

Workflow находится в:

    .github/workflows/ci.yml

Типовые ошибки, которые здесь фиксировались

    Попытка выполнить URL в bash
    Неправильно:

http://127.0.0.1:3000

Правильно:

    открыть в браузере, или

curl http://127.0.0.1:3000

    Порт занят
    Ошибка вида:
    Bind for 0.0.0.0:80 failed: port is already allocated
    Решение:

    использовать другой внешний порт (например 3000/8080), или

    остановить контейнер/сервис, который уже держит порт:

docker ps
docker stop <id>

    Смешивание Node и Python

    requirements.txt ставится через pip, а не npm
    Правильно:

pip install -r requirements.txt

    pip run lint не существует
    pip не умеет run. Для Python lint используют ruff/flake8 и т.п.

Зачем этот репозиторий

    как минимальный шаблон CI под Docker

    как “песочница” для отработки ошибок сборки/портов/пайплайна
